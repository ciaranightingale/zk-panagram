{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":8576566866916416243,"abi":{"parameters":[{"name":"guess","type":{"kind":"field"},"visibility":"private"},{"name":"address","type":{"kind":"field"},"visibility":"public"},{"name":"expected_hash","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"61":{"source":"use dep::keccak256;\n\nfn main(guess: Field, address: pub Field, expected_hash: pub Field) {\n    let addr_sqrt: Field = address * address;\n    let guess_bytes: [u8; 32] = guess.to_be_bytes();\n    let guess_hash: [u8; 32] = keccak256::keccak256(guess_bytes, 32);\n    assert_eq(addr_sqrt, address * address);\n    assert_eq(Field::from_be_bytes(guess_hash), expected_hash);\n}","path":"/Users/ciaranightingale/code/Updraft/zk-ciara-repos/zk-panagram/circuits/src/main.nr"},"63":{"source":"mod tests;\n\nuse std::runtime::is_unconstrained;\nuse std::hash::keccak::keccakf1600;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[no_predicates]\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer[j];\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n","path":"/Users/ciaranightingale/nargo/github.com/noir-lang/keccak256/v0.1.0/src/keccak256.nr"}},"names":["main"],"brillig_names":["directive_to_radix","directive_invert","directive_integer_quotient"]}